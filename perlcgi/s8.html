<HTML>
<TITLE>Part 8</Title>

<body>

<h3>1 Session management and maintaining state</h3>

Session management or state maintenance poses a challenge for any 
server-side web 
language. This is because, in contrast to stand-alone applications,
server-side applications transfer data between servers and clients.
A server-side application does not have full control over the data
at the client's computer. A client can delete, modify or add to any
data. Therefore client-data cannot be trusted. 
<p>
Sessions are created to minimise the risk of data corruption. All user
data is stored on the server and associated with a session ID. 
Data retrieval is based on the session ID. A security check must be 
performed on any data, which a user enters, before the data is stored
on the server. It is not necessary to perform security checks on
data that is retrieved from the server. This is in contrast to CGI
applications without sessions: in that case a security check must
be performed on user data every time the data is used! 
<p>
The session IDs should be generated by the server and should be long 
and complicated enough to deter users from manual tampering with the IDs. 
Session IDs are passed from page to page either 
<li>by using hidden HTML form text or 
<li>by using the query string or
<li>by using cookies (on the client computer).
<p>
The user data, which is associated with a session ID can be stored on 
the server
<li>in a file
<li>in a database.
<p>
This approach reduces the number of security checks that must be performed
on user data. Because users can modify their cookies (or disallow cookies)
and can modify hidden HTML form text or query strings, it is possible
for a hacker to break into another user's session.
This problem affects all server-side web languages, not just Perl.
For highly sensitive applications, other measures, such as encryption (SSL)
and password protection must be added. 
<p>
There are several different libraries available for Perl which provide
session management. An example is CGI::Session.

<h4>1.1 Hidden Text - Exercise</h4>

1) Create a form that asks a user for his/her name and some comments.
Then create two CGI scripts that create a response. The first script
displays the information which the user has submitted ("Hello $name.
These are your comments: $comments") and asks the user whether he/she
really wants to submit the information. The second script is invoked
by the first one and displays "Thank you $name. Your comments 
have been submitted: $comments".
<p>
To implement this add a form and hidden tags to the first CGI script,
such as
<p><font color=blue>
&#60;input type='hidden' name='hiddenname' value=\"$name\"&#62;<br>
&#60;input type='hidden' name='hiddencomments' value=\"$comments\"&#62;
</font><p>
The second CGI script retrieves these strings via
<p><font color=blue>
my $name = param('hiddenname');<br>
my $comments = param('hiddencomments');
</font><p>

<h4>1.2 Cookies - Exercise</h4>

2) Use a cookie instead of hidden text in the previous exercise.
<p>
The following code in the first CGI script sets a cookie.

<p><font color=blue>
$cookiedata = $name."|".$comments;<br>
$cookie = cookie(-name=>'nameandcomments',-value=>"$cookiedata",
                     -expires=>'+1h');<br>
print header(-cookie=>$cookie);  <br>
</font><p>

The second CGI script retrieves the cookie similarly to retrieving
parameters:

<p><font color=blue>
$cookiedata = cookie(-name=>'nameandcomments');<br>
($name, $comments) = split(/\|/,$cookiedata);
<p></font>

<h4>1.3 Session management with CGI::Session</h4>

3) Use HTML::Template and CGI::Session for the same task as in the
two previous exercises. The framework for the code for the
first CGI script is below:
<p>
<font color=blue>
#!/usr/local/bin/perl<br>
use CGI qw(:standard -debug); <br>
use CGI::Session;<br>
use HTML::Template;<br>
########################################################################<br>
my $template_text1 = &#60;&#60;EOS;<br>
# HTML for an error message if security problems<br>
EOS<br>
<br>
my $template_text2 = &#60;&#60;EOS;<br>
# HTML for the response if no security problems<br>
EOS<br>
########################################################################<br>
my $cgi = new CGI;<br>
my $session = new CGI::Session(undef,$cgi,{Directory=&#62;
'/home/yourdir/tmp'});<br>
$cookie = $cgi-&#62;cookie(CGISESSID =&#62; $session-&#62;id );<br>
print $cgi-&#62;header(-cookie=&#62;$cookie);<br>
my $template1 = HTML::Template-&#62;new(scalarref =&#62;\$template_text1 );<br>
my $template2 = HTML::Template-&#62;new(scalarref =&#62;\$template_text2,
                                    associate =&#62; $cgi);<br>
########################################################################<br>
if ( check the security of the data) {<br>
    print $template1-&#62;output(); }<br>
else {<br>
    $session-&#62;save_param($cgi);<br>
    print $template2-&#62;output(); }<br>
}
</font>
<p>
Notes: 
<li> /home/yourdir/tmp should be some directory which is only
readable by you. The session data will be stored in that directory.
<li> "associate => $cgi" makes all CGI parameters available for the 
template. To avoid potential security problems the
"print $template2->output()" statement should be within an if-else
statement, which checks security.
<li>Instead of using "associate => $cgi", it is also possible to send
the parameters from the cgi object to the session to the template
individually with:<br>
$session->param("name", $cgi->param("name"));<br>
$template2->param(name => $session->param("name"));<br>
But before printing the session parameters directly, they should be save into
other variables.
<li>"$session->save_param($cgi);" saves all CGI parameters into the session.
<li>If a user disables cookies, the session ID can be transmitted
as a parameter CGISESSID.
<li>More information about CGI::Session can be found
<a href="http://search.cpan.org/~sherzodr/CGI-Session-3.95/Session/
Tutorial.pm">here</a>
<p>
For the second CGI file, you'll need something like
<p>
<font color=blue>
my $cgi = new CGI;<br>
my $session = new CGI::Session(undef, $cgi, 
{Directory=>'/home/yourdir/tmp'});<br>
print $cgi->header();<br>
my $template = HTML::Template->new(scalarref =>\$template_text,
associate => $session);<br>
</font>
<p>
After those lines, all CGI parameters are available within the template.
Note, that in this case the template is associated with the session
object, not with the cgi object.

<h4>1.5 Hit Counter - Exercise</h4>

4) Create a file that contains
only the number "0". Your CGI script must open that file for reading;
read the first line of the file into a scalar variable; increase the 
number by one; close the file; open the file again for writing (not
appending); write the number to the file; close the file.

<h3>2 Optional: Password protected pages</h3>

Access to web sites on an Apache Server can be controlled using the
HTACCESS files. Two files are involved in access control: a
.www-password file is created and saved in a directory above the
public_html directory. Any directory under the public_html
directory can then be protected by saving a .htaccess file in
the directory. It should be noted that htaccess only encrypts
the password but not the pages. Therefore it does not provide high
level security. Furthermore, htaccess does not protect your files
from being viewed by other Unix users on the same computer.

<h4>2.1 Optional exercise</h4>

Create a password protected directory under your public_html
directory. Specific instructions:

<li>Go to your top level directory and type
<font color=blue>htpasswd ~/.www-password remoteuser</font>
at the Unix prompt. You can replace <font color=blue>remoteuser</font> with 
a login name you want to use for your pages. Type in a
password when prompted. Note that this should be a new password,
different from any password you are using for other purposes.
The .www-password file must be readable by others.
<li>Create a new directory under public_html. Go to the directory.
Create a file called .htaccess with the following content:<br>
<font color=blue>
AuthType Basic<br>
AuthName "Password Required"<br>
AuthUserFile /home/yourmatricnumber/.www-password<br>
AuthGroupFile /dev/null<br>
&#60;Limit GET POST&#62;<br>
require user remoteuser<br>
&#60;/Limit&#62; <br>
</font>
where <font color=blue>yourmatricnumber</font> is your matric number
and <font color=blue>remoteuser</font> is the same name you used above.

<li>Change the .htaccess file to readable (chmod 644 .htaccess)
<li>If you view any html from that directory through your browser,
you should now be prompted for a username and password.

<h3>3 Optional: Abbreviations for writing HTML tags</h3>

The CGI.pm module provides standard subroutines for printing certain
HTML code fragments. For example,
<font color=blue> print h1("Tea");
</font> prints an h1 header.
To use these subroutines, the script must contain the line
"use CGI qw(:standard);".

<p>

<li>print header();  <br><li>
print start_html(-title=>"title_goes_here",-BGCOLOR=>'yellow');   <br><li>
print h1("some heading"); <br><li>
print hr(); <br><li>
print p("text");<br><li>
print start_form(); <br><li>
print a({href=>"url_goes_here.html"},"link text goes here"); <br><li>
print textfield(-name=>'field_name',-default=>'starting value',
-size=>50,-maxlength=>80);<br><li>
print textarea(-name=>'foo',-default=>'starting value',-rows=>10,
-columns=>50);<br><li>
print password_field(-name=>'secret',-value=>'starting value',
-size=>50, -maxlength=>80);<br><li>
print popup_menu(-name=>'menu_name',-values=>['one','two','three'],
-default=>'two');<br><li>
print scrolling_list(-name=>'list_name',-values=>['one','two','three'],
-default=>['one','three'];-size=>3, -multiple=>'true',
-labels=>\%labels);<br><li>
print checkbox_group(-name=>'group_name',-values=>['one','two','three'],
 -default=>['one','three'],-linebreak=>'true',-labels=>\%labels);<br><li>
print checkbox(-name=>'checkbox_name',   -checked=>'checked',
 -value=>'TURNED ON', -label=>'Turn me on'); <br><li>
print radio_group(-name=>'group_name',-values=>['one','two','three'],
 -default=>'one',     -linebreak=>'true', -labels=>\%labels);<br><li>
print submit(-name=>'button_name',        -value=>'value');<br><li>
print hidden(-name=>'hidden_name', -default=>['value1','value2']);<br><li>
print reset(); <br><li>
print end_form(); 

</body>
</html>
